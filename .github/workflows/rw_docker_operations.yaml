name: 'Docker Operations'
description: 'Build, test, and optionally push Docker images with security scanning'

on:
  workflow_call:
    inputs:
      operation:
        description: 'Operation to perform: build, test, push, security-scan'
        required: true
        type: string
      image-name:
        description: 'Docker image name (without registry)'
        required: false
        default: ${{ github.repository }}
        type: string
      registry:
        description: 'Container registry to use'
        required: false
        default: 'ghcr.io'
        type: string
      version:
        description: 'Image version/tag'
        required: false
        default: 'latest'
        type: string
      platforms:
        description: 'Target platforms for multi-arch build'
        required: false
        default: 'linux/amd64,linux/arm64'
        type: string
      health-check-port:
        description: 'Port for health check'
        required: false
        default: '8000'
        type: string
      health-check-path:
        description: 'Health check endpoint path'
        required: false
        default: '/health'
        type: string
      enable-sbom:
        description: 'Generate and upload SBOM'
        required: false
        default: false
        type: boolean
      enable-signing:
        description: 'Sign image with cosign'
        required: false
        default: false
        type: boolean
      cache-enabled:
        description: 'Enable build cache'
        required: false
        default: true
        type: boolean

    secrets:
      dockerhub-user:
        description: 'Registry username'
        required: false
      registry-token:
        description: 'Registry authentication token'
        required: false

    outputs:
      image-digest:
        description: 'Built image digest'
        value: ${{ jobs.docker_operations.outputs.digest }}
      image-tags:
        description: 'Built image tags'
        value: ${{ jobs.docker_operations.outputs.tags }}
      image-name:
        description: 'Built image name'
        value: ${{ jobs.docker_operations.outputs.image_name }}
      image-tag:
        description: 'Built image tag'
        value: ${{ jobs.docker_operations.outputs.image_tag }}
      image-ref:
        description: 'Built image reference (name:tag)'
        value: ${{ jobs.docker_operations.outputs.image_ref }}

jobs:
  docker_operations:
    name: Docker ${{ inputs.operation }}
    runs-on: ubuntu-latest
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      tags: ${{ steps.meta.outputs.tags }}
      image_name: ${{ steps.image_meta.outputs.image_name }}
      image_tag: ${{ steps.image_meta.outputs.image_tag }}
      image_ref: ${{ steps.image_meta.outputs.image_ref }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initial Docker image tag name
        id: initial-docker-tag-meta
        run: |
          image_name=$(echo "${{ inputs.registry }}/${{ inputs.image-name }}" | cut -d/ -f1 | tr '[:upper:]' '[:lower:]')
          echo "ðŸ³ Docker image name: $image_name"
          echo "image_name=$image_name" >> "$GITHUB_OUTPUT"

      - name: Set image metadata outputs
        id: image_meta
        run: |
          IMAGE_NAME="${{ steps.initial-docker-tag-meta.outputs.image_name }}"
          IMAGE_TAG="${{ inputs.version }}"
          IMAGE_REF="$IMAGE_NAME:$IMAGE_TAG"
          
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "image_ref=$IMAGE_REF" >> "$GITHUB_OUTPUT"
          
          echo "ðŸ“Š Image metadata:"
          echo "  Name: $IMAGE_NAME"
          echo "  Tag: $IMAGE_TAG"
          echo "  Reference: $IMAGE_REF"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-flags: --debug

      - name: Login to Container Registry
        if: inputs.operation == 'push'
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.dockerhub-user }}
          password: ${{ secrets.registry-token }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.initial-docker-tag-meta.outputs.image_name }}
          tags: |
            type=raw,value=${{ inputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build Docker image
        if: contains(fromJSON('["build", "test", "push", "security-scan"]'), inputs.operation)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          push: ${{ inputs.operation == 'push' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: ${{ inputs.operation == 'push' && inputs.platforms || 'linux/amd64' }}
          cache-from: ${{ inputs.cache-enabled == 'true' && 'type=gha' || '' }}
          cache-to: ${{ inputs.cache-enabled == 'true' && 'type=gha,mode=max' || '' }}
          load: ${{ inputs.operation != 'push' }}

      - name: Test Docker image
        if: contains(fromJSON('["test", "push"]'), inputs.operation)
        run: |
          echo "ðŸ§ª Testing Docker image functionality..."
          
          # Get the local image tag for testing
          if [ "${{ inputs.operation }}" = "push" ]; then
            IMAGE_TAG="${{ steps.initial-docker-tag-meta.outputs.image_name }}:${{ inputs.version }}"
          else
            IMAGE_TAG="${{ steps.initial-docker-tag-meta.outputs.image_name }}:${{ inputs.version }}"
          fi
          
          echo "Testing image: $IMAGE_TAG"
          
          # Start container in background
          docker run -d --name test-container \
            -p ${{ inputs.health-check-port }}:${{ inputs.health-check-port }} \
            -e CLICKUP_API_TOKEN=test_token \
            $IMAGE_TAG
          
          # Wait for container to be ready and test health endpoint
          echo "Waiting for container to start..."
          timeout=30
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            if docker ps | grep -q test-container; then
              if curl -f http://127.0.0.1:${{ inputs.health-check-port }}${{ inputs.health-check-path }} > /dev/null 2>&1; then
                echo "âœ… Health check passed"
                break
              fi
            fi
            
            sleep 2
            elapsed=$((elapsed + 2))
            echo "Waiting... ($elapsed/$timeout seconds)"
          done
          
          # Check final status
          if [ $elapsed -ge $timeout ]; then
            echo "âŒ Health check failed after $timeout seconds"
            echo "Container logs:"
            docker logs test-container
            exit 1
          fi
          
          # Cleanup
          docker stop test-container || true
          docker rm test-container || true
          
          echo "âœ… Docker image test completed successfully"

      - name: Ensure local image exists (guard)
        if: inputs.operation == 'security-scan'
        shell: bash
        run: |
          IMAGE_NAME="${{ steps.initial-docker-tag-meta.outputs.image_name }}"
          IMAGE_TAG="${{ inputs.version }}"
          IMAGE_REF="$IMAGE_NAME:$IMAGE_TAG"
          
          echo "ðŸ” Checking for image: $IMAGE_REF"
          
          if ! docker image inspect "$IMAGE_REF" >/dev/null 2>&1; then
            echo "::group::Available local images"
            docker images "$IMAGE_NAME" --format '{{.Repository}}:{{.Tag}}' | head -20 || true
            echo "::endgroup::"
            echo "::error::Image $IMAGE_REF not found locally."
            echo "Expected image: $IMAGE_REF"
            echo "This indicates a tag mismatch between build and security scan operations."
            echo "Make sure the build job produced this exact tag before running security scan."
            exit 1
          fi
          
          echo "âœ… Image $IMAGE_REF found locally"

      - name: Install security tools
        if: inputs.operation == 'security-scan' || inputs.enable-sbom || inputs.enable-signing
        run: |
          # Install Cosign
          if [ "${{ inputs.enable-signing }}" = "true" ]; then
            echo "Installing Cosign..."
            curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
            sudo mv cosign-linux-amd64 /usr/local/bin/cosign
            sudo chmod +x /usr/local/bin/cosign
          fi
          
          # Install Grype for vulnerability scanning
          if [ "${{ inputs.operation }}" = "security-scan" ]; then
            echo "Installing Grype..."
            curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          fi
          
          # Install Syft for SBOM generation
          if [ "${{ inputs.enable-sbom }}" = "true" ] || [ "${{ inputs.operation }}" = "security-scan" ]; then
            echo "Installing Syft..."
            curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          fi

      - name: Prepare for security scan and SBOM generation
        if: inputs.operation == 'security-scan'
        run: |
          sudo apt-get install jq

      - name: Security scan and SBOM generation
        if: inputs.operation == 'security-scan'
        id: security-scan
        shell: bash
        run: |
          set -euo pipefail
          
          IMAGE_NAME="${{ steps.initial-docker-tag-meta.outputs.image_name }}"
          IMAGE_TAG="${{ inputs.version }}"
          IMAGE_REF="$IMAGE_NAME:$IMAGE_TAG"
          
          echo "ðŸ” Starting security scan for: $IMAGE_REF"
          
          # Step 1: Generate SBOM from Docker image
          echo "::group::Generating SBOM from Docker image"
          if syft "$IMAGE_REF" -o spdx-json --file sbom-docker.spdx.json; then
            echo "âœ… SBOM generated from Docker image"
            PRIMARY_SBOM="sbom-docker.spdx.json"
          else
            echo "âŒ Failed to generate SBOM from Docker image"
            PRIMARY_SBOM=""
          fi
          echo "::endgroup::"
          
          # Step 2: Fallback SBOM generation from workspace
          echo "::group::Generating fallback SBOM from workspace"
          if syft . -o spdx-json --file sbom-workspace.spdx.json; then
            echo "âœ… Fallback SBOM generated from workspace"
            FALLBACK_SBOM="sbom-workspace.spdx.json"
          else
            echo "âŒ Failed to generate fallback SBOM from workspace"
            FALLBACK_SBOM=""
          fi
          echo "::endgroup::"
          
          # Determine which SBOM to use
          if [[ -n "$PRIMARY_SBOM" && -f "$PRIMARY_SBOM" ]]; then
            FINAL_SBOM="$PRIMARY_SBOM"
            echo "ðŸ“„ Using primary SBOM from Docker image"
            # Copy as standard name for consistency
            cp "$PRIMARY_SBOM" sbom.spdx.json
          elif [[ -n "$FALLBACK_SBOM" && -f "$FALLBACK_SBOM" ]]; then
            FINAL_SBOM="$FALLBACK_SBOM"
            echo "ðŸ“„ Using fallback SBOM from workspace"
            # Copy fallback as primary for consistency
            cp "$FALLBACK_SBOM" sbom.spdx.json
          else
            echo "::error::Failed to generate any SBOM. Both Docker image and workspace scans failed."
            exit 1
          fi
          
          # Step 3: Vulnerability scanning with Grype
          echo "::group::Vulnerability scanning with Grype"
          echo "ðŸ” Scanning Docker image for vulnerabilities..."
          
          # Scan the Docker image
          if grype "$IMAGE_REF" -o json --file grype-vulnerabilities.json; then
            echo "âœ… Vulnerability scan completed"
            
            # Generate human-readable report
            grype "$IMAGE_REF" -o table > grype-report.txt || true
            
            # Check for high/critical vulnerabilities
            HIGH_CRITICAL=$(jq -r '[.matches[] | select(.vulnerability.severity == "High" or .vulnerability.severity == "Critical")] | length' grype-vulnerabilities.json 2>/dev/null || echo "0")
            
            echo "ðŸ“Š Vulnerability Summary:"
            echo "  High/Critical vulnerabilities found: $HIGH_CRITICAL"
            
            if [[ "$HIGH_CRITICAL" -gt 0 ]]; then
              echo "::warning::Found $HIGH_CRITICAL high/critical vulnerabilities. Review grype-report.txt for details."
            else
              echo "âœ… No high/critical vulnerabilities found"
            fi
            
            # Export for GitHub outputs
            echo "vulnerabilities_found=$HIGH_CRITICAL" >> $GITHUB_OUTPUT
          else
            echo "âŒ Vulnerability scanning failed, continuing with SBOM generation"
            echo "vulnerabilities_found=unknown" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"
          
          # Step 4: Sign SBOM if signing is enabled
          if [[ "${{ inputs.enable-signing }}" == "true" ]]; then
            echo "::group::Signing SBOM"
            echo "ðŸ” Signing SBOM..."
            if cosign sign-blob --yes sbom.spdx.json --output-signature sbom.spdx.json.sig; then
              echo "âœ… SBOM signed successfully"
            else
              echo "âŒ Failed to sign SBOM"
            fi
            echo "::endgroup::"
          fi
          
          # Step 5: Generate attestation if signing is enabled
          if [[ "${{ inputs.enable-signing }}" == "true" ]]; then
            echo "::group::Generating attestation"
            echo "ðŸ“ Generating attestation..."
            if cosign attest --yes --predicate sbom.spdx.json --type spdxjson "$IMAGE_REF"; then
              echo "âœ… Attestation generated successfully"
            else
              echo "âŒ Failed to generate attestation"
            fi
            echo "::endgroup::"
          fi
          
          echo "ðŸŽ‰ Security scan completed successfully"

      - name: Generate SBOM (legacy)
        if: inputs.enable-sbom && inputs.operation != 'security-scan'
        run: |
          echo "ðŸ” Generating SBOM..."
          IMAGE_TAG="(echo '${{ steps.initial-docker-tag-meta.outputs.image_name }}:${{ inputs.version }}' | tr '[:upper:]' '[:lower:]')"
          syft $IMAGE_TAG -o spdx-json --file sbom.spdx.json
          echo "âœ… SBOM generated"

      - name: Upload security scan artifacts
        if: inputs.operation == 'security-scan'
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-${{ inputs.version }}
          path: |
            sbom*.spdx.json
            grype-*.json
            grype-*.txt
          retention-days: 30

      - name: Upload SBOM (legacy)
        if: inputs.enable-sbom && inputs.operation != 'security-scan'
        uses: actions/upload-artifact@v4
        with:
          name: docker-sbom-${{ inputs.version }}
          path: sbom.spdx.json
          retention-days: 30

      - name: Sign Docker image
        if: inputs.enable-signing && inputs.operation == 'push'
        run: |
          echo "ðŸ” Signing Docker image..."
          IMAGE_TAG="${{ steps.initial-docker-tag-meta.outputs.image_name }}:${{ inputs.version }}"
          cosign sign --yes $IMAGE_TAG
          
          if [ "${{ inputs.version }}" != "latest" ]; then
            cosign sign --yes ${{ steps.initial-docker-tag-meta.outputs.image_name }}:latest
          fi
          echo "âœ… Image signed successfully"

      - name: Attest SBOM
        if: inputs.enable-sbom && inputs.enable-signing && inputs.operation == 'push'
        run: |
          echo "ðŸ” Attesting SBOM..."
          IMAGE_TAG="${{ steps.initial-docker-tag-meta.outputs.image_name }}:${{ inputs.version }}"
          cosign attest --yes --predicate sbom.spdx.json --type spdxjson $IMAGE_TAG
          echo "âœ… SBOM attestation completed"

      - name: Operation summary
        run: |
          echo "## Docker Operation Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Operation**: ${{ inputs.operation }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ steps.initial-docker-tag-meta.outputs.image_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Platforms**: ${{ inputs.platforms }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SBOM**: ${{ inputs.enable-sbom && 'âœ… Generated' || (inputs.operation == 'security-scan' && 'âœ… Generated (Security Scan)') || 'âŒ Disabled' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Signing**: ${{ inputs.enable-signing && 'âœ… Enabled' || 'âŒ Disabled' }}" >> $GITHUB_STEP_SUMMARY
          
          # Add security scan specific details
          if [[ "${{ inputs.operation }}" == "security-scan" ]]; then
            echo "- **Vulnerability Scan**: ${{ steps.security-scan.outputs.vulnerabilities_found != 'unknown' && 'âœ… Completed' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
            if [[ "${{ steps.security-scan.outputs.vulnerabilities_found }}" != "unknown" ]]; then
              echo "- **High/Critical Vulnerabilities**: ${{ steps.security-scan.outputs.vulnerabilities_found }}" >> $GITHUB_STEP_SUMMARY
            fi
            echo "- **Defensive Checks**: âœ… Image existence verified" >> $GITHUB_STEP_SUMMARY
            echo "- **Fallback SBOM**: âœ… Available if Docker scan fails" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "- **Status**: âœ… Completed successfully" >> $GITHUB_STEP_SUMMARY
